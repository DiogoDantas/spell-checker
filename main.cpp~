#include <iostream>
#include <fstream>
#include <cstring>
#include <vector>
#include <time.h>

using namespace std;

/****************************** STRUCTS DECLARATION *******************************/
typedef struct node
{
    const char* string;
    node* next_Node;

}Node;

typedef struct header
{
    Node* first_Node;
    int size;

}Header;

typedef struct wrong_word
{
    int line;
    int column;
    string word;
}Wrong_word;

/****************************** STRUCTS DECLARATION *******************************/

const int buckets = 25609; //number of buckets used in hash table
int cont_correct = 0; //number of correct words
int cont_wrong=0; //number of wrong words
float time; //time calculated in proccess (used to print results)
clock_t initial_time, final_time; //time = final - initial
string words_list[307860]; //copy of dictionary words (used to generate hash table)
Header table[buckets]; //array of Headers that will save a linked list and the size
std::vector<Wrong_word> vector_wrong; //vector used to save the wrong words found in text




/****
 *Author: Daniel J. Bernstein

 * hash_djb2(): This is one of the best
* known hash functions for strings. Because it is both computed very
* fast and distributes very well.
*
* The magic of number 33, i.e. why it works better than many other
* constants, prime or not, has never been adequately explained by
* anyone.
 *
 * Parameters: a string to be converted (hashed)
 *
 * Return: A int number that represents the string hashed
 *
 ****/

int hash_djb2(const char* string)
{
    unsigned long int hash = 5381;
    int c;

        while(c = *string++)
            hash = ((hash << 5) + hash) + c; /* hash * 33 + c */

    hash = hash % buckets; //the buckets define the range
    return hash;
}



/****
 *Author: Diogo Dantas and Higor Anjos

 * to_lowerCase(): This function is used to convert a string to its equivalent lowercase form
 *
 * Parameters: a string to be converted to lowercase
 *
 * Return: a string in lowercase form
 *
 ****/

string to_lowerCase(string word)
{
    int i=0;

                if(word[0]!=tolower(word[0])) { //if the word starts with lowercase, isn't necessary to convert
                        while(word[i]!='\0'){
                            word[i]=tolower(word[i]); //converts to lower
                            i++;
                        }
                }

                return word;
}

/****
 *Author: Diogo Dantas and Higor Anjos

 * preprocessing(): This function does all preprocessing needed to use the spell-checker
 *
 * Parameters: none
 *
 * Return: none
 *
 ****/
void preprocessing(){

    ifstream file;
    file.open ("dictionary.txt"); //opening file
    if (!file.is_open()) return; //if something gets wrong...

/******* CREATING AND PREPARING THE ARRAY ****/

    for (int i = 0; i < buckets; ++i) //setting all to 0 or NULL
    {
        Header * tmp = new Header;
        table[i] = *tmp;
        table[i].size = 0;
        table[i].first_Node = NULL;
    }
/******* CREATING AND PREPARING THE ARRAY ****/

/******* CONVERTING TO LOWERCASE AND SAVING IN THE ARRAY*****/

        string word;
        int j=0;

    while (file >> word) //jumps from word to word
        {

            words_list[j++] = to_lowerCase(word);  //converting


        }

file.close();

/******* CONVERTING TO LOWERCASE AND SAVING IN THE ARRAY*****/

/******* APPLYING HASH AND GENERATING TABLE *****/
    for (int i = 0; i < j; ++i)
    {
            int hashed = hash_djb2(words_list[i].c_str()); //using the dictionary words to hash
            table[hashed].size++; //increasing the size of the linked list of this bucket
            Node* tmp = new Node;
                    if (!table[hashed].first_Node) //if first
                    {
                        table[hashed].first_Node = tmp;
                        table[hashed].first_Node->next_Node = NULL;
                        table[hashed].first_Node->string = words_list[i].c_str();

                    } else {
                        tmp->string = words_list[i].c_str();
                        tmp->next_Node =  table[hashed].first_Node;
                        table[hashed].first_Node = tmp;

                    }
    }
/******* APPLYING HASH AND GENERATING TABLE *****/

} //END OF preprocessing()

/****
 *Author: Diogo Dantas and Higor Anjos

 * compare(): This function sweeps an linked list comparing its nodes
 *
 * Parameters: string to be compared
 *
 * Return: a boolean indicating if is equal or not
 *
 ****/

bool compare(string word)
{
    word = to_lowerCase(word);
    int hashed = hash_djb2(word.c_str());


    Node* aux = table[hashed].first_Node;
        while(aux) //while is not in the end of the list
        {
            if (word == aux->string)
                return true;

            aux=aux->next_Node;
        }

    return false;

}

/************** PARSING TEXT *******************************/
void parse_text(){
    const int MAX_CHARS_PER_LINE = 512;
    const int MAX_TOKENS_PER_LINE = 100;
    const char* const DELIMITER = "  ,.:?;!'\"";
    int line_count = -1;

    // create a file-reading object
  ifstream file;
  file.open("teste.txt"); // open a file
  if (!file.good())
    cout<<"problem loading file"<<endl; // exit if file not found

  // read each line of the file
  while (!file.eof())
  {
    line_count++;
    // read an entire line into memory
    char buf[MAX_CHARS_PER_LINE];
    file.getline(buf, MAX_CHARS_PER_LINE);

    // parse the line into blank-delimited tokens
    int n = 0; // a for-loop index

    // array to store memory addresses of the tokens in buf
    const char* token[MAX_TOKENS_PER_LINE] = {}; // initialize to 0

    // parse the line
    token[0] = strtok(buf, DELIMITER); // first token
    if (token[0]) // zero if line is blank
    {
      for (n = 1; n < MAX_TOKENS_PER_LINE; n++)
      {
        token[n] = strtok(0, DELIMITER); // subsequent tokens
        if (!token[n]) break; // no more tokens
      }
    }

    // process (print) the tokens
    for (int i = 0; i < n; i++){ // n = #of tokens

           if(compare(token[i])){
                cont_correct++;
            }else{
                cont_wrong++;
                Wrong_word * tmp = new Wrong_word;
                tmp->line = line_count;
                tmp->column = i;
                tmp->word = token[i];
                vector_wrong.push_back(*tmp);
                delete tmp;
            }

       }

  }

    file.close();


}
/************** PARSING TEXT *******************************/

/************** PRINTING RESULTS ******************************/
void print_results(){
cout<<endl;
cout<<"Número total de palavras do texto: "<<cont_correct+cont_wrong<<endl;
cout<<"time de verificação: "<<time<<"ms."<<endl;
cout<<"Número de palavras que falharam no spell check: "<<cont_wrong<<endl;
cout<<"Lista de palavras que falharam no spell check: "<<endl;
cout<<endl;
cout<<"Linha  -  Coluna  : Palavra "<<endl;
cout<<"------------------------------------------"<<endl;

for (int i = 0; i < cont_wrong; ++i)
    {
        cout<<vector_wrong[i].line+1<<" - "<<vector_wrong[i].column+1<<" : "<<vector_wrong[i].word<<endl;
    }

}
/************** PRINTING RESULTS **************************************/

int  main(int argc, char const *argv[])
{
    preprocessing();

    initial_time = clock();
    parse_text();
    final_time = clock();

    time = ((float)(final_time - initial_time)/CLOCKS_PER_SEC)*1000;

    print_results();
    return 0;
}
